#! /usr/bin/env python
# Copyright 2018 Martin C. Frith

from __future__ import print_function

import functools
import gzip
import logging
import math
import optparse
import os
import re
import signal
import sys
from itertools import chain, groupby
from operator import itemgetter

def myOpen(fileName):  # faster than fileinput
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName, "rt")  # xxx dubious for Python2
    return open(fileName)

def connectedComponent(adjacencyList, isNew, i):
    stack = [(i, False)]
    while stack:
        j, isFlipped = stack.pop()
        if isNew[j]:
            yield j, isFlipped
            isNew[j] = False
            for k, isOpposite in adjacencyList[j]:
                stack.append((k, isOpposite != isFlipped))

def connectedComponents(adjacencyList):
    isNew = [True for i in adjacencyList]
    numOfNodes = len(adjacencyList)
    for i in range(numOfNodes):
        if isNew[i]:
            yield sorted(connectedComponent(adjacencyList, isNew, i))

def fieldsFromMaf(line):
    _, seqName, start, span, strand, seqLen, seq = line.split()
    beg = int(start)
    if strand == "-":
        beg -= int(seqLen)  # use negative coordinates for reverse strands
    return seqName, beg, seq

def splitAtBigGaps(opts, refBeg, qryBeg, refSeq, qrySeq):
    minGap = int(math.ceil(opts.min_gap))
    alnLen = len(qrySeq)
    gapString = "-" * min(minGap, alnLen + 1)
    alnPos = 0
    while alnPos < alnLen:
        gapBeg = qrySeq.find(gapString, alnPos)
        if gapBeg < 0:
            gapBeg = gapEnd = alnLen
        else:
            gapEnd = gapBeg + minGap
            while gapEnd < alnLen and qrySeq[gapEnd] == "-":
                gapEnd += 1
        dist = gapBeg - alnPos
        refEnd = refBeg + dist - refSeq.count("-", alnPos, gapBeg)
        qryEnd = qryBeg + dist - qrySeq.count("-", alnPos, gapBeg)
        if dist:
            yield qryBeg, qryEnd, refBeg, refEnd
        refBeg = refEnd + (gapEnd - gapBeg)
        qryBeg = qryEnd
        alnPos = gapEnd

def alignmentsFromLines(opts, lines):
    mafLines = []
    refSeq = qrySeq = None
    mismap = 0.0
    for line in lines:
        if line.isspace():
            if qrySeq and mismap <= opts.max_mismap:
                yield out
            mafLines = []
            refSeq = qrySeq = None
            mismap = 0.0
        elif line[0] != "#":
            if line[0] == "a":
                for i in line.split():
                    if i.startswith("mismap="):
                        mismap = float(i[7:])
            elif line[0] == "s":
                if refSeq is None:
                    refName, refBeg, refSeq = fieldsFromMaf(line)
                else:
                    qryName, qryBeg, qrySeq = fieldsFromMaf(line)
                    alns = splitAtBigGaps(opts, refBeg, qryBeg, refSeq, qrySeq)
                    out = qryName, refName, alns, mafLines
            mafLines.append(line)
    if qrySeq and mismap <= opts.max_mismap:
        yield out

def isCircularChromosome(name):
    return name in ("chrM", "M")  # xxx ???

def isKnownChromosome(name):
    unknownPrefixes = "chrUn", "Un"  # xxx ???
    return not name.startswith(unknownPrefixes)

def chromosomeFromName(name):
    return name.split("_")[0]  # e.g. chr5_random -> chr5

def isDifferentChromosomes(nameX, nameY):
    return (isKnownChromosome(nameX) and isKnownChromosome(nameY) and
            chromosomeFromName(nameX) != chromosomeFromName(nameY))

def refNameAndStrand(alignment):
    return alignment[3], alignment[4] < 0

def knownChromosomes(alignments):
    for i in alignments:
        refName = i[3]
        if isKnownChromosome(refName):
            yield chromosomeFromName(refName)

def isInterChromosome(alignments):
    """Is any pair of alignments on different chromosomes?"""
    return len(set(knownChromosomes(alignments))) > 1

def isInterStrand(alignments):
    """Is any pair of alignments on opposite strands of the same chromosome?"""
    names = set(i[3] for i in alignments)
    namesAndStrands = set(map(refNameAndStrand, alignments))
    return len(namesAndStrands) > len(names)

def isNonlinear(sortedAlignmentsOfOneQuery, opts):
    """Is any pair of alignments non-colinear on the same strand?"""
    maxCoordinates = {}
    for i in sortedAlignmentsOfOneQuery:
        if isCircularChromosome(i[3]):
            continue
        k = refNameAndStrand(i)
        if k in maxCoordinates:
            m = maxCoordinates[k]
            if m >= i[4] + opts.min_rev:
                return True
            if i[5] > m:
                maxCoordinates[k] = i[5]
        else:
            maxCoordinates[k] = i[5]
    return False

def isBigGap(sortedAlignmentsOfOneQuery, opts):
    """Is any pair of adjacent aligments separated by a big genomic gap?"""
    for j, y in enumerate(sortedAlignmentsOfOneQuery):
        if j:
            x = sortedAlignmentsOfOneQuery[j - 1]
            if refNameAndStrand(x) == refNameAndStrand(y):
                if y[4] - x[5] >= opts.min_gap:
                    return True
    return False

def isRearranged(opts, alignmentsOfOneQuery):
    return ("C" in opts.types and isInterChromosome(alignmentsOfOneQuery) or
            "S" in opts.types and isInterStrand(alignmentsOfOneQuery) or
            "N" in opts.types and isNonlinear(alignmentsOfOneQuery, opts) or
            "G" in opts.types and isBigGap(alignmentsOfOneQuery, opts))

def newAlnFromOldAln(oldAln, qryNum, alnNum):
    qryName, qryBeg, qryEnd, refName, refBeg, refEnd = oldAln
    if refBeg < 0:
        refBeg, refEnd = -refEnd, -refBeg
        qryBeg, qryEnd = -qryEnd, -qryBeg
    return qryNum, qryBeg, qryEnd, refName, refBeg, refEnd, alnNum, []

def qryFwdAlns(alignmentGroup):
    for qryName, refName, alns, junk in alignmentGroup:
        for qryBeg, qryEnd, refBeg, refEnd in alns:
            if qryBeg >= 0:
                yield qryName, qryBeg, qryEnd, refName, refBeg, refEnd
            else:  # use forward strand of query:
                yield qryName, -qryEnd, -qryBeg, refName, -refEnd, -refBeg

def alignmentsPerRearrangedQuerySequence(opts, fileNames):
    qryNum = 0
    alnNum = 0
    for fileNum, fileName in enumerate(fileNames):
        logging.info("reading {0}...".format(fileName))
        alignments = alignmentsFromLines(opts, myOpen(fileName))
        for qryName, group in groupby(alignments, itemgetter(0)):
            group = list(group)
            alignmentsOfOneQuery = sorted(qryFwdAlns(group))
            if isRearranged(opts, alignmentsOfOneQuery):
                newAlns = []
                for i in alignmentsOfOneQuery:
                    newAlns.append(newAlnFromOldAln(i, qryNum, alnNum))
                    alnNum += 1
                alignmentTexts = [i[3] for i in group]
                yield newAlns, alignmentTexts, fileNum + 1
                qryNum += 1

def overlappingAlignmentPairs(myAlignmentsInGenomeOrder):
    stash = []
    for alnB in myAlignmentsInGenomeOrder:
        newStash = []
        for alnA in stash:
            if alnA[3] == alnB[3] and alnA[5] > alnB[4]:
                yield alnA, alnB
                newStash.append(alnA)
        stash = newStash
        stash.append(alnB)

def addNgOverlaps(okAlignmentsInGenomeOrder, ngAlignmentsInGenomeOrder):
    logging.info("finding overlaps for exclusion...")
    stash = []
    ngPos = 0
    for alnA in okAlignmentsInGenomeOrder:
        refNameA, refBegA, refEndA = alnA[3:6]
        while ngPos < len(ngAlignmentsInGenomeOrder):
            alnB = ngAlignmentsInGenomeOrder[ngPos]
            if (alnB[3], alnB[4]) >= (refNameA, refBegA):
                break
            stash.append(alnB)
            ngPos += 1
        stash = [i for i in stash if i[3] == refNameA and i[5] > refBegA]
        alnA[7].extend(i[6] for i in stash)
        ngEnd = ngPos
        while ngEnd < len(ngAlignmentsInGenomeOrder):
            alnB = ngAlignmentsInGenomeOrder[ngEnd]
            if alnB[3] > refNameA or alnB[4] >= refEndA:
                break
            alnA[7].append(alnB[6])
            ngEnd += 1

def addOverlaps(myAlignmentsInGenomeOrder):
    logging.info("finding overlaps...")
    for alnA, alnB in overlappingAlignmentPairs(myAlignmentsInGenomeOrder):
        if alnA[0] < alnB[0]:
            alnA[7].append(alnB[6])
        if alnB[0] < alnA[0]:
            alnB[7].append(alnA[6])

def delOverlaps(alignments):
    for i in alignments:
        myList = i[7]
        del myList[:]

def overlapsOfOneQuery(alignments, alignmentsOfOneQuery):
    for alnA in alignmentsOfOneQuery:
        alnNumA = alnA[6]
        for alnNumB in alnA[7]:
            qryNumB = alignments[alnNumB][0]
            yield qryNumB, alnNumA, alnNumB

def isSameQueryStrand(alnA, alnB):
    return (alnA[1] < 0) == (alnB[1] < 0)

def isAdjacent(alnX, alnY):
    return alnX[6] + 1 == alnY[6] or alnY[6] + 1 == alnX[6]

def isNonlinearPair(opts, alnX, alnY):
    if alnX[3] != alnY[3]:
        return "C" in opts.types and isDifferentChromosomes(alnX[3], alnY[3])
    if not isSameQueryStrand(alnX, alnY):
        return "S" in opts.types
    if alnX[1] < alnY[1]:        
        gap = alnY[4] - alnX[5]
    else:
        gap = alnX[4] - alnY[5]
    if "N" in opts.types and gap + opts.min_rev <= 0:
        if not isCircularChromosome(alnX[3]):
            return True
    if "G" in opts.types and gap >= opts.min_gap:
        if isAdjacent(alnX, alnY):
            return True
    return False

def alignmentEdges(alnA, alnB, isGetEnds):
    if isGetEnds:
        return -alnA[2], -alnA[5], -alnB[2], -alnB[5]
    else:
        return alnA[1], alnA[4], alnB[1], alnB[4]

def isSharedRearrangement(opts, alnAX, alnAY, alnBX, alnBY):
    # alnAX of query sequence A overlaps alnBX of query sequence B
    # alnAY of query sequence A overlaps alnBY of query sequence B
    # alnAX is upstream of alnAY in query sequence A

    qryAX, refAX, qryBX, refBX = alignmentEdges(alnAX, alnBX, alnAX[1] >= 0)
    qryAY, refAY, qryBY, refBY = alignmentEdges(alnAY, alnBY, alnAY[1] < 0)

    qryDistanceA = qryAX + qryAY
    qryDistanceB = qryBX + qryBY
    begDiff = refAX - refBX
    endDiff = refBY - refAY
    if abs(qryDistanceB - qryDistanceA + begDiff - endDiff) > opts.max_diff:
        return False

    if alnAX[3] != alnAY[3] or not isSameQueryStrand(alnAX, alnAY):
        return True

    gapA = refAX + refAY
    gapB = refBX + refBY
    gapAtoB = refAX + refBY
    gapBtoA = refBX + refAY

    if gapA < 0:  # type "N"
        if gapB + opts.min_rev > 0:
            return False
        if gapB * 2 > gapA or gapA * 2 > gapB:
            return False
        return gapAtoB < 0 and gapBtoA < 0
    else:  # type "G"
        if gapB < opts.min_gap or not isAdjacent(alnBX, alnBY):
            return False
        if gapB * 2 < gapA or gapA * 2 < gapB:
            return False
        return gapAtoB > 0 and gapBtoA > 0

def sharedRearrangement(opts, alignments, overlapsBetweenTwoQueries):
    # "A" refers to a query sequence
    # "B" refers to a different query sequence
    groups = groupby(overlapsBetweenTwoQueries, itemgetter(1))
    overlapsPerAlnA = [(alnNumA, [i[2] for i in v]) for alnNumA, v in groups]

    for alnNumAY, alnNumsBY in overlapsPerAlnA:
        for alnNumAX, alnNumsBX in overlapsPerAlnA:
            if alnNumAX == alnNumAY:
                break
            alnAX = alignments[alnNumAX]
            alnAY = alignments[alnNumAY]
            if not isNonlinearPair(opts, alnAX, alnAY):
                continue
            for alnNumBY in alnNumsBY:
                for alnNumBX in alnNumsBX:
                    if alnNumBX == alnNumBY:
                        continue
                    alnBX = alignments[alnNumBX]
                    alnBY = alignments[alnNumBY]
                    isSameStrand = isSameQueryStrand(alnAY, alnBY)
                    if isSameQueryStrand(alnAX, alnBX) != isSameStrand:
                        continue
                    isUpstreamInQueryA = (alnNumAX < alnNumAY)
                    isUpstreamInQueryB = (alnNumBX < alnNumBY)
                    isSameOrder = (isUpstreamInQueryA == isUpstreamInQueryB)
                    if isSameOrder != isSameStrand:
                        continue
                    if isSharedRearrangement(opts, alnAX, alnAY, alnBX, alnBY):
                        return "-+"[isSameStrand]
    return None

def isNoSharedRearrangement(opts, alignments, alignmentsOfOneOkQuery):
    overlaps = sorted(overlapsOfOneQuery(alignments, alignmentsOfOneOkQuery))
    for qryNumB, g in groupby(overlaps, itemgetter(0)):
        if sharedRearrangement(opts, alignments, g):
            return False
    return True

def linksBetweenQueries(opts, alignments, alignmentsPerQuery):
    logging.info("linking...")
    for alignmentsOfOneQuery in alignmentsPerQuery:
        qryNumA = alignmentsOfOneQuery[0][0]
        overlaps = sorted(overlapsOfOneQuery(alignments, alignmentsOfOneQuery))
        for qryNumB, g in groupby(overlaps, itemgetter(0)):
            strand = sharedRearrangement(opts, alignments, g)
            if strand:
                yield qryNumA, qryNumB, strand == "-"

def isOverlap(alnA, alnB):
    return alnA[3] == alnB[3] and alnA[4] < alnB[5] and alnA[5] > alnB[4]

def prevAlignment(alignments, thisAlignment):
    alnNum = thisAlignment[6]
    if alnNum == 0: return None
    a = alignments[alnNum - 1]
    return a if a[0] == thisAlignment[0] else None

def nextAlignment(alignments, thisAlignment):
    alnNum = thisAlignment[6]
    if alnNum == len(alignments) - 1: return None
    a = alignments[alnNum + 1]
    return a if a[0] == thisAlignment[0] else None

def addJumpIfShared(alignments, alnA, alnB):
    alnAX = prevAlignment(alignments, alnA)
    isSameStrand = isSameQueryStrand(alnA, alnB)
    if isSameStrand:
        alnBX = prevAlignment(alignments, alnB)
    else:
        alnBX = nextAlignment(alignments, alnB)
    if alnAX is None or alnBX is None:
        return
    if not isOverlap(alnAX, alnBX):
        return
    if isSameQueryStrand(alnAX, alnBX) != isSameStrand:
        return
    if isSharedRearrangement(opts, alnAX, alnA, alnBX, alnB):
        alnA[7].append(alnB[0])

def addSharedJumps(alignments, myAlignmentsInGenomeOrder):
    logging.info("finding shared jumps...")
    for alnA, alnB in overlappingAlignmentPairs(myAlignmentsInGenomeOrder):
        if alnA[0] != alnB[0]:
            addJumpIfShared(alignments, alnA, alnB)
            addJumpIfShared(alignments, alnB, alnA)

def isAllJumpsSupported(opts, alignmentsOfOneQuery):
    for j, y in enumerate(alignmentsOfOneQuery):
        if j:
            x = alignmentsOfOneQuery[j - 1]
            if isNonlinearPair(opts, x, y):
                if len(set(y[7])) < opts.min_cov:
                    return False
    return True

def querySortKey(alignmentsOfOneQuery):
    return min(a[3:6] for a in alignmentsOfOneQuery)

def clumpSortKey(alignmentsPerQuery, clump):
    k = min(querySortKey(alignmentsPerQuery[i]) for i, isFlipped in clump)
    return -len(clump), k

def fileNumsFromText(text):
    if text:
        return [int(i) for i in text.split(",")]
    return []

def alignmentsInGenomeOrder(alignmentsPerQuery):
    logging.info("sorting...")
    alignments = chain.from_iterable(alignmentsPerQuery)
    return sorted(alignments, key=itemgetter(3, 4))

def alignmentsOfCoveredQueries(opts, alignments, alignmentsPerQuery):
    while True:
        oldLen = len(alignmentsPerQuery)
        logging.info("queries: " + str(oldLen))
        myAlignmentsInGenomeOrder = alignmentsInGenomeOrder(alignmentsPerQuery)
        if opts.min_cov:
            addSharedJumps(alignments, myAlignmentsInGenomeOrder)
            logging.info("excluding...")
            alignmentsPerQuery = [i for i in alignmentsPerQuery
                                  if isAllJumpsSupported(opts, i)]
            delOverlaps(myAlignmentsInGenomeOrder)
        if len(alignmentsPerQuery) == oldLen:
            return alignmentsPerQuery, myAlignmentsInGenomeOrder

def printMaf(lines, isFlipped):
    lines = [re.split("(\s+)", i, 5) for i in lines]
    sLines = [i for i in lines if i[0] == "s"]
    qryLine = sLines[-1]
    qryName = qryLine[2]
    qryNameEnd = qryName[-1]
    isAddChar = qryNameEnd not in "+-"
    qryBase = qryName if isAddChar else qryName[:-1]
    newQryName = qryBase + "-+"[isFlipped == (qryNameEnd == "-")]
    if isFlipped:
        strand = qryLine[8]
        qryLine[8] = "-+"[strand == "-"]
    sLineCount = 0
    for line in lines:
        if line[0] in "sq":
            if line[0] == "s":
                sLineCount += 1
            if sLineCount == len(sLines) and line[2] == qryName:
                line[2] = newQryName
            elif isAddChar:
                line[2] += " "
        elif line[0] == "p":
            if isAddChar:
                line[0] += " "
        print("".join(line), end="")
    print()

def rearrangedSequenceClumps(opts, args):
    logLevel = logging.INFO if opts.verbose else logging.WARNING
    logging.basicConfig(format="%(filename)s: %(message)s", level=logLevel)

    fileNumsToInclude = fileNumsFromText(opts.yes)
    fileNumsToExclude = fileNumsFromText(opts.no)

    fileNames = args if args else ["-"]
    dataPerQuery = list(alignmentsPerRearrangedQuerySequence(opts, fileNames))
    alignmentsPerQuery = [i[0] for i in dataPerQuery]
    alignmentTextsPerQuery = [i[1] for i in dataPerQuery]
    fileNumsPerQuery = [i[2] for i in dataPerQuery]
    alignments = list(chain.from_iterable(alignmentsPerQuery))

    alignmentsPerOkQuery = [i[0] for i in dataPerQuery
                            if i[2] not in fileNumsToExclude]

    alignmentsPerNgQuery = [i[0] for i in dataPerQuery
                            if i[2] in fileNumsToExclude]

    okAlignmentsInGenomeOrder = alignmentsInGenomeOrder(alignmentsPerOkQuery)
    ngAlignmentsInGenomeOrder = alignmentsInGenomeOrder(alignmentsPerNgQuery)
    addNgOverlaps(okAlignmentsInGenomeOrder, ngAlignmentsInGenomeOrder)

    logging.info("excluding...")
    alignmentsPerKeptQuery = [i for i in alignmentsPerOkQuery
                              if isNoSharedRearrangement(opts, alignments, i)]
    delOverlaps(okAlignmentsInGenomeOrder)

    cov = alignmentsOfCoveredQueries(opts, alignments, alignmentsPerKeptQuery)
    alignmentsPerKeptQuery, myAlignmentsInGenomeOrder = cov

    addOverlaps(myAlignmentsInGenomeOrder)

    adjacencyList = [[] for i in alignmentsPerQuery]
    links = linksBetweenQueries(opts, alignments, alignmentsPerKeptQuery)
    for qryNumA, qryNumB, isOpposite in links:
        adjacencyList[qryNumA].append((qryNumB, isOpposite))
        adjacencyList[qryNumB].append((qryNumA, isOpposite))

    logging.info("clumping...")
    allClumps = connectedComponents(adjacencyList)
    clumps = [i for i in allClumps if len(i) >= opts.min_seqs]
    clumps.sort(key=functools.partial(clumpSortKey, alignmentsPerQuery))

    print("#", os.path.basename(sys.argv[0]), *sys.argv[1:])
    print()

    wantedClumps = 0
    for clumpNum, clump in enumerate(clumps):
        fileNums = set(fileNumsPerQuery[qryNum] for qryNum, isFlipped in clump)
        if any(i not in fileNums for i in fileNumsToInclude):
            continue
        wantedClumps += 1
        head = "# PART clump{0}-{1}".format(clumpNum + 1, len(clump))
        if len(fileNames) > 1:
            head += "-{0}".format("_".join(map(str, sorted(fileNums))))
        print(head)
        print()
        for qryNum, isFlipped in clump:
            for t in alignmentTextsPerQuery[qryNum]:
                printMaf(t, isFlipped)
            print()

    txt = "wrote {0} of {1} clumps\n".format(wantedClumps, len(clumps))
    sys.stdout.flush()
    sys.stderr.write(txt)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] maf-file(s)"
    descr = "Find clumps of rearranged query sequences in query-to-reference alignments."
    op = optparse.OptionParser(usage=usage, description=descr)
    op.add_option("-m", "--max-mismap", type="float", default=1e-6,
                  metavar="PROB", help="discard any alignment with "
                  "mismap probability > PROB (default=%default)")
    op.add_option("-s", "--min-seqs", type="int", default=2, metavar="N",
                  help="minimum query sequences per clump (default=%default)")
    op.add_option("-t", "--types", metavar="LETTERS", default="CSNG", help=
                  "rearrangement types: C=inter-chromosome, S=inter-strand, "
                  "N=non-colinear, G=big gap (default=%default)")
    op.add_option("-g", "--min-gap", type="float", default=10000, metavar="BP",
                  help='minimum forward jump in the reference sequence '
                  'counted as a "big gap" (default=%default)')
    op.add_option("-r", "--min-rev", type="float", default=1000, metavar="BP",
                  help='minimum reverse jump in the reference sequence '
                  'counted as "non-colinear" (default=%default)')
    op.add_option("-d", "--max-diff", type="float", default=1000, metavar="BP",
                  help="maximum query-length difference for "
                  "shared rearrangement (default=%default)")
    op.add_option("-c", "--min-cov", type="int", default=0, metavar="N", help=
                  "omit any query with any rearrangement shared by < N "
                  "other queries (default=%default)")
    op.add_option("-y", "--yes", metavar="LIST", default="",
                  help="require clumps to include the specified files")
    op.add_option("-n", "--no", metavar="LIST", default="", help=
                  "omit query sequences that share rearrangements with the "
                  "specified files")
    op.add_option("-v", "--verbose", action="count",
                  help="show progress messages")
    opts, args = op.parse_args()
    rearrangedSequenceClumps(opts, args)
