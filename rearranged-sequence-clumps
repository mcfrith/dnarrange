#! /usr/bin/env python
# Copyright 2018 Martin C. Frith

from __future__ import print_function

import gzip
import math
import optparse
import os
import signal
import sys
from itertools import chain, groupby
from operator import itemgetter

def myOpen(fileName):  # faster than fileinput
    if fileName == "-":
        return sys.stdin
    if fileName.endswith(".gz"):
        return gzip.open(fileName)
    return open(fileName)

def log(opts, s):
    if opts.verbose:
        sys.stderr.write(s + "\n")

def connectedComponent(adjacencyList, isNew, i):
    stack = [i]
    while stack:
        j = stack.pop()
        if isNew[j]:
            yield j
            isNew[j] = False
            for k in adjacencyList[j]:
                stack.append(k)

def connectedComponents(adjacencyList):
    isNew = [True for i in adjacencyList]
    numOfNodes = len(adjacencyList)
    for i in range(numOfNodes):
        if isNew[i]:
            yield sorted(connectedComponent(adjacencyList, isNew, i))

def fieldsFromMaf(line):
    _, seqName, start, span, strand, seqLen, seq = line.split()
    beg = int(start)
    if strand == "-":
        beg -= int(seqLen)  # use negative coordinates for reverse strands
    return seqName, beg, seq

def findBigGap(text, start, minGap):
    g = "-" * min(minGap, len(text) + 1)
    i = text.find(g, start)
    if i < 0:
        i = len(text)
    j = i + minGap
    while j < len(text) and text[j] == "-":
        j += 1
    return i, j

def splitAtBigGaps(opts, refFields, qryFields):
    refName, refBeg, refSeq = refFields
    qryName, qryBeg, qrySeq = qryFields
    minGap = int(math.ceil(opts.min_gap))
    alnPos = 0
    while alnPos < len(qrySeq):
        gapBeg, gapEnd = findBigGap(qrySeq, alnPos, minGap)
        dist = gapBeg - alnPos
        refEnd = refBeg + dist - refSeq.count("-", alnPos, gapBeg)
        qryEnd = qryBeg + dist - qrySeq.count("-", alnPos, gapBeg)
        if dist:
            if qryBeg >= 0:
                yield qryName, qryBeg, qryEnd, refName, refBeg, refEnd
            else:  # use forward strand of query:
                yield qryName, -qryEnd, -qryBeg, refName, -refEnd, -refBeg
        refBeg = refEnd + (gapEnd - gapBeg)
        qryBeg = qryEnd
        alnPos = gapEnd

def alignmentsFromMaf(opts, lines):
    mafLines = []
    refFields = qryFields = None
    mismap = 0.0
    for line in lines:
        if line.isspace():
            if qryFields and mismap <= opts.max_mismap:
                yield out
            mafLines = []
            refFields = qryFields = None
            mismap = 0.0
        elif line[0] != "#":
            mafLines.append(line)
            if line[0] == "s":
                if refFields:
                    qryFields = fieldsFromMaf(line)
                    alns = list(splitAtBigGaps(opts, refFields, qryFields))
                    qryName = qryFields[0]
                    out = qryName, alns, mafLines
                else:
                    refFields = fieldsFromMaf(line)
            elif line[0] == "a":
                for i in line.split():
                    if i.startswith("mismap="):
                        mismap = float(i[7:])
    if qryFields and mismap <= opts.max_mismap:
        yield out

def isCircularChromosome(name):
    return name in ("chrM", "M")  # xxx ???

def isKnownChromosome(name):
    unknownPrefixes = "chrUn", "Un"  # xxx ???
    return not name.startswith(unknownPrefixes)

def chromosomeFromName(name):
    return name.split("_")[0]  # e.g. chr5_random -> chr5

def isDifferentChromosomes(nameX, nameY):
    return (isKnownChromosome(nameX) and isKnownChromosome(nameY) and
            chromosomeFromName(nameX) != chromosomeFromName(nameY))

def refNameAndStrand(alignment):
    return alignment[3], alignment[4] < 0

def knownChromosomes(alignments):
    for i in alignments:
        refName = i[3]
        if isKnownChromosome(refName):
            yield chromosomeFromName(refName)

def isInterChromosome(alignments):
    """Is any pair of alignments on different chromosomes?"""
    return len(set(knownChromosomes(alignments))) > 1

def isInterStrand(alignments):
    """Is any pair of alignments on opposite strands of the same chromosome?"""
    names = set(i[3] for i in alignments)
    namesAndStrands = set(map(refNameAndStrand, alignments))
    return len(namesAndStrands) > len(names)

def isNonlinear(sortedAlignmentsOfOneQuery, opts):
    """Is any pair of alignments non-colinear on the same strand?"""
    maxCoordinates = {}
    for i in sortedAlignmentsOfOneQuery:
        if isCircularChromosome(i[3]):
            continue
        k = refNameAndStrand(i)
        if k in maxCoordinates:
            m = maxCoordinates[k]
            if m >= i[4] + opts.min_rev:
                return True
            if i[5] > m:
                maxCoordinates[k] = i[5]
        else:
            maxCoordinates[k] = i[5]
    return False

def isBigGap(sortedAlignmentsOfOneQuery, opts):
    """Is any pair of adjacent aligments separated by a big genomic gap?"""
    for j, y in enumerate(sortedAlignmentsOfOneQuery):
        if j:
            x = sortedAlignmentsOfOneQuery[j - 1]
            if refNameAndStrand(x) == refNameAndStrand(y):
                if y[4] - x[5] >= opts.min_gap:
                    return True
    return False

def isRearranged(opts, alignmentsOfOneQuery):
    return ("C" in opts.types and isInterChromosome(alignmentsOfOneQuery) or
            "S" in opts.types and isInterStrand(alignmentsOfOneQuery) or
            "N" in opts.types and isNonlinear(alignmentsOfOneQuery, opts) or
            "G" in opts.types and isBigGap(alignmentsOfOneQuery, opts))

def newAlnFromOldAln(oldAln, qryNum, alnNum):
    qryName, qryBeg, qryEnd, refName, refBeg, refEnd = oldAln
    if refBeg < 0:
        refBeg, refEnd = -refEnd, -refBeg
        qryBeg, qryEnd = -qryEnd, -qryBeg
    return qryNum, qryBeg, qryEnd, refName, refBeg, refEnd, alnNum, []

def alignmentsPerRearrangedQuerySequence(opts, fileNames):
    qryNum = 0
    alnNum = 0
    for fileNum, fileName in enumerate(fileNames):
        log(opts, "reading {0}...".format(fileName))
        alignments = alignmentsFromMaf(opts, myOpen(fileName))
        for k, v in groupby(alignments, itemgetter(0)):
            v = list(v)
            alignmentsOfOneQuery = sorted(chain.from_iterable(i[1] for i in v))
            if isRearranged(opts, alignmentsOfOneQuery):
                newAlns = []
                for i in alignmentsOfOneQuery:
                    newAlns.append(newAlnFromOldAln(i, qryNum, alnNum))
                    alnNum += 1
                alignmentTexts = [i[2] for i in v]
                yield newAlns, alignmentTexts, fileNum + 1
                qryNum += 1

def addOverlaps(alignmentsSortedByGenome):
    stash = []
    for alnB in alignmentsSortedByGenome:
        newStash = []
        for alnA in stash:
            if alnA[3] == alnB[3] and alnA[5] > alnB[4]:
                if alnA[0] < alnB[0]:
                    alnA[7].append(alnB[6])
                if alnB[0] < alnA[0]:
                    alnB[7].append(alnA[6])
                newStash.append(alnA)
        stash = newStash
        stash.append(alnB)

def overlapsOfOneQuery(alignments, alignmentsOfOneQuery):
    for alnA in alignmentsOfOneQuery:
        alnNumA = alnA[6]
        for alnNumB in alnA[7]:
            qryNumB = alignments[alnNumB][0]
            yield qryNumB, alnNumA, alnNumB

def isSameQueryStrand(alnA, alnB):
    return (alnA[1] < 0) == (alnB[1] < 0)

def isAdjacent(alnX, alnY):
    return alnX[6] + 1 == alnY[6] or alnY[6] + 1 == alnX[6]

def isNonlinearPair(opts, alnX, alnY):
    if alnX[3] != alnY[3]:
        return "C" in opts.types and isDifferentChromosomes(alnX[3], alnY[3])
    if not isSameQueryStrand(alnX, alnY):
        return "S" in opts.types
    if alnX[1] < alnY[1]:        
        gap = alnY[4] - alnX[5]
    else:
        gap = alnX[4] - alnY[5]
    if "N" in opts.types and gap + opts.min_rev <= 0:
        if not isCircularChromosome(alnX[3]):
            return True
    if "G" in opts.types and gap >= opts.min_gap:
        if isAdjacent(alnX, alnY):
            return True
    return False

def isSharedRearrangement(opts, alnAX, alnAY, alnBX, alnBY):
    # alnAX of query sequence A overlaps alnBX of query sequence B
    # alnAY of query sequence A overlaps alnBY of query sequence B
    if alnAX[3] != alnAY[3] or not isSameQueryStrand(alnAX, alnAY):
        return True
    if alnAX[1] > alnAY[1]:
        alnAX, alnAY = alnAY, alnAX
        alnBX, alnBY = alnBY, alnBX
    endAX = alnAX[5]
    begAY = alnAY[4]
    endBX = alnBX[5]
    begBY = alnBY[4]
    gapA = begAY - endAX
    gapB = begBY - endBX
    if gapA < 0:  # type "N"
        if gapB + opts.min_rev > 0:
            return False
        if gapB * 2 > gapA or gapA * 2 > gapB:
            return False
        return endBX > begAY and begBY < endAX
    else:  # type "G"
        if gapB < opts.min_gap or not isAdjacent(alnBX, alnBY):
            return False
        if gapB * 2 < gapA or gapA * 2 < gapB:
            return False
        return endBX < begAY and begBY > endAX

def isAnySharedRearrangement(opts, alignments, overlapsPerAlnA):
    # "A" refers to a query sequence
    # "B" refers to a different query sequence
    for alnNumAY, alnNumsBY in overlapsPerAlnA:
        for alnNumAX, alnNumsBX in overlapsPerAlnA:
            if alnNumAX == alnNumAY:
                break
            alnAX = alignments[alnNumAX]
            alnAY = alignments[alnNumAY]
            if not isNonlinearPair(opts, alnAX, alnAY):
                continue
            for alnNumBY in alnNumsBY:
                for alnNumBX in alnNumsBX:
                    if alnNumBX == alnNumBY:
                        continue
                    alnBX = alignments[alnNumBX]
                    alnBY = alignments[alnNumBY]
                    isSameStrand = isSameQueryStrand(alnAY, alnBY)
                    if isSameQueryStrand(alnAX, alnBX) != isSameStrand:
                        continue
                    isUpstreamInQueryA = (alnNumAX < alnNumAY)
                    isUpstreamInQueryB = (alnNumBX < alnNumBY)
                    isSameOrder = (isUpstreamInQueryA == isUpstreamInQueryB)
                    if isSameOrder != isSameStrand:
                        continue
                    if isSharedRearrangement(opts, alnAX, alnAY, alnBX, alnBY):
                        return True
    return False

def linksBetweenQueries(opts, alignments, alignmentsPerQuery):
    for alignmentsOfOneQuery in alignmentsPerQuery:
        qryNumA = alignmentsOfOneQuery[0][0]
        overlaps = sorted(overlapsOfOneQuery(alignments, alignmentsOfOneQuery))
        for qryNumB, g in groupby(overlaps, itemgetter(0)):
            overlapsPerAlnA = [(alnNumA, [i[2] for i in h])
                               for alnNumA, h in groupby(g, itemgetter(1))]
            if isAnySharedRearrangement(opts, alignments, overlapsPerAlnA):
                yield qryNumA, qryNumB

def connectedClumps(opts, alignmentsPerQuery, adjacencyList):
    for i in connectedComponents(adjacencyList):
        if len(i) >= opts.min_seqs:
            yield [alignmentsPerQuery[j] for j in i]

def clumpSortKey(clump):
    return -len(clump), min(min(a[3:6] for a in q) for q in clump)

def fileNumsFromText(text):
    if text:
        return [int(i) for i in text.split(",")]
    return []

def rearrangedSequenceClumps(opts, args):
    fileNumsToInclude = fileNumsFromText(opts.yes)
    fileNumsToExclude = fileNumsFromText(opts.no)

    fileNames = args if args else ["-"]
    dataPerQuery = list(alignmentsPerRearrangedQuerySequence(opts, fileNames))
    alignmentsPerQuery = [i[0] for i in dataPerQuery]
    alignmentTextsPerQuery = [i[1] for i in dataPerQuery]
    fileNumsPerQuery = [i[2] for i in dataPerQuery]
    alignments = list(chain.from_iterable(alignmentsPerQuery))

    log(opts, "sorting...")
    alignmentsSortedByGenome = sorted(alignments, key=itemgetter(3, 4))
    log(opts, "finding overlaps...")
    addOverlaps(alignmentsSortedByGenome)

    log(opts, "linking...")
    adjacencyList = [[] for i in alignmentsPerQuery]
    for i, j in linksBetweenQueries(opts, alignments, alignmentsPerQuery):
        adjacencyList[i].append(j)
        adjacencyList[j].append(i)

    log(opts, "clumping...")
    clumps = list(connectedClumps(opts, alignmentsPerQuery, adjacencyList))
    clumps.sort(key=clumpSortKey)

    print("#", os.path.basename(sys.argv[0]), *sys.argv[1:])
    print()

    wantedClumps = 0
    for clumpNum, clump in enumerate(clumps):
        fileNums = set(fileNumsPerQuery[i[0][0]] for i in clump)
        if any(i not in fileNums for i in fileNumsToInclude):
            continue
        if any(i in fileNums for i in fileNumsToExclude):
            continue
        wantedClumps += 1
        head = "# PART clump{0}-{1}".format(clumpNum + 1, len(clump))
        if len(fileNames) > 1:
            head += "-{0}".format("_".join(map(str, sorted(fileNums))))
        print(head)
        print()
        for i in clump:
            qryNum = i[0][0]
            for t in alignmentTextsPerQuery[qryNum]:
                for line in t:
                    print(line, end="")
                print()
            print()

    txt = "wrote {0} of {1} clumps\n".format(wantedClumps, len(clumps))
    sys.stdout.flush()
    sys.stderr.write(txt)

if __name__ == "__main__":
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)  # avoid silly error message
    usage = "%prog [options] maf-file(s)"
    descr = "Find clumps of rearranged query sequences in query-to-reference alignments."
    op = optparse.OptionParser(usage=usage, description=descr)
    op.add_option("-m", "--max-mismap", type="float", default=1e-6,
                  metavar="PROB", help="discard any alignment with "
                  "mismap probability > PROB (default=%default)")
    op.add_option("-s", "--min-seqs", type="int", default=2, metavar="N",
                  help="minimum query sequences per clump (default=%default)")
    op.add_option("-t", "--types", metavar="LETTERS", default="CSNG", help=
                  "rearrangement types: C=inter-chromosome, S=inter-strand, "
                  "N=non-colinear, G=big gap (default=%default)")
    op.add_option("-g", "--min-gap", type="float", default=10000, metavar="BP",
                  help='minimum forward jump in the reference sequence '
                  'counted as a "big gap" (default=%default)')
    op.add_option("-r", "--min-rev", type="float", default=1000, metavar="BP",
                  help='minimum reverse jump in the reference sequence '
                  'counted as "non-colinear" (default=%default)')
    op.add_option("-y", "--yes", metavar="LIST", default="",
                  help="require clumps to include the specified files")
    op.add_option("-n", "--no", metavar="LIST", default="",
                  help="require clumps to exclude the specified files")
    op.add_option("-v", "--verbose", action="count",
                  help="show progress messages")
    opts, args = op.parse_args()
    rearrangedSequenceClumps(opts, args)
